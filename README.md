| 함수 이름            | get_next_line                                                                 |
|----------------------|-------------------------------------------------------------------------------|
| 프로토타입           | char *get_next_line(int fd);                                                  |
| 매개변수             | get_next_line.c, get_next_line_utils.c, get_next_line.h                       |
| 반환값               | 읽혀진 라인 : 한 줄이 제대로 읽힘, NULL : 읽을 라인이 더이상 없거나 에러 발생 |
| 사용가능한 외부 함수 | read, malloc, free                                                            |
| 설명                 | 파일 디스크립터로부터 한 줄을 읽고, 반환하는 함수를 작성하시오.               |
- get_next_line 함수를 반복문 안에서 호출하면, 파일 디스크립터에 존재하는 텍스트를 `EOF 전까지 한 번에 한 줄씩` 읽어들일 수 있습니다.
- `더이상 읽어올 것이 없거나 에러가 발생하면 NULL을 반환`하여야 합니다. - 표준입력도 처리 - `-D BUFFER_SIZE=xx` 플래그를 이용하여 컴파일 되어야 합니다. 이것은 여러분의 get_next_line에서 read함수를 호출하기 위한 buffer size로 사용될 것이며, Moulinette와 평가자가 임의로 값을 수정하여 테스트할 것
- `gcc -Wall -Wextra -Werror -D BUFFER_SIZE=42 <파일들>.c`
- `read` 함수는 `컴파일 시에 정의되는 BUFFER_SIZE`를 사용해야 합니다
- get_next_line.h (헤더 파일)에는 적어도 get_next_line 함수의 프로토타입이 존재

- BUFFER_SIZE 값이 9999인 경우에도 함수는 여전히 작동하나요? BUFFER_SIZE 값이 1이라면? 10000000이라면? 왜 그런지 아시나요?
- get_next_line이 호출될 때마다 가능한 한 적게 읽어들이도록 해야 합니다. 만약 newline을 만나면, 현재 라인을 반환해야 합니다. 전체 파일을 읽어들인 다음에 한줄씩 처리하려 하지 마세요
- 파일로부터, redirection으로부터, stdin으로부터의 읽기를 시도해 보세요. 표준 출력에 newline을 보낼 때 프로그램은 어떻게 동작하나요? CTRL-D는요?
 
- 만약 동일한 파일 디스크립터의 두 호출 사이에서, 첫 번째 fd에서 EOF에 도달하기 전에 다른 파일로 전환될 경우, 우리는 get_next_line이 정의되지 않은 동작을 가진다고 생각합니다.
- 바이너리 파일을 읽을 때 정의되지 않은 동작을 가진다고 생각하셔야 합니다. 그러나 여러분이 원한다면 이러한 동작을 논리적으로 구현하셔도 됩니다.
- 전역 변수는 금지되어 있습니다.
- 중요: 'eof에 도달하였고 \n이 존재하지 않을 때'를 제외하고, 함수가 반환하는 문자열 한 줄에는 \n이 포함되어야 합니다. 

### BONUS
- 하나의 정적변수로 get_next_line 성공하기.
- get_next_line을 사용하여 여러 파일 설명자를 관리할 수 있습니다 
- 예를 들어, 파일 디스크립터 3, 4, 5가 읽기에 액세스 가능하면 각 디스크립터에서 읽기 스레드를 잃지 않고 3에서 한 번, 4에서 한 번, 3에서 다시 한 번, 5에서 한 번 등을 호출할 수 있습니다.
- get_next_line을 사용하여 여러 개의 파일 디스크립터를 관리할 수 있는 것. 
- 예를 들어, 파일 디스크립터 3, 4, 5에 접근 가능한 경우, get_next_line은 각 디스크립터의 리딩 스레드를 잃지 않은 채로 3에서 한 번, 4에서 한 번, 다시 3에서 한 번, 5에서 한 번 호출될 수 있습니다.
