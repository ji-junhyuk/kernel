| 함수 이름            | get_next_line                                                                 |
|----------------------|-------------------------------------------------------------------------------|
| 프로토타입           | char *get_next_line(int fd);                                                  |
| 매개변수             | get_next_line.c, get_next_line_utils.c, get_next_line.h                       |
| 반환값               | 읽혀진 라인 : 한 줄이 제대로 읽힘, NULL : 읽을 라인이 더이상 없거나 에러 발생 |
| 사용가능한 외부 함수 | read, malloc, free                                                            |
| 설명                 | 파일 디스크립터로부터 한 줄을 읽고, 반환하는 함수를 작성하시오.               |
- get_next_line 함수를 반복문 안에서 호출하면, 파일 디스크립터에 존재하는 텍스트를 `EOF 전까지 한 번에 한 줄씩` 읽어들일 수 있습니다.
- `더이상 읽어올 것이 없거나 에러가 발생하면 NULL을 반환`하여야 합니다. - 표준입력도 처리 - `-D BUFFER_SIZE=xx` 플래그를 이용하여 컴파일 되어야 합니다. 이것은 여러분의 get_next_line에서 read함수를 호출하기 위한 buffer size로 사용될 것이며, Moulinette와 평가자가 임의로 값을 수정하여 테스트할 것
- `gcc -Wall -Wextra -Werror -D BUFFER_SIZE=42 <파일들>.c`
- `read` 함수는 `컴파일 시에 정의되는 BUFFER_SIZE`를 사용해야 합니다
- get_next_line.h (헤더 파일)에는 적어도 get_next_line 함수의 프로토타입이 존재

- BUFFER_SIZE 값이 9999인 경우에도 함수는 여전히 작동하나요? BUFFER_SIZE 값이 1이라면? 10000000이라면? 왜 그런지 아시나요?
- get_next_line이 호출될 때마다 가능한 한 적게 읽어들이도록 해야 합니다. 만약 newline을 만나면, 현재 라인을 반환해야 합니다. 전체 파일을 읽어들인 다음에 한줄씩 처리하려 하지 마세요
- 파일로부터, redirection으로부터, stdin으로부터의 읽기를 시도해 보세요. 표준 출력에 newline을 보낼 때 프로그램은 어떻게 동작하나요? CTRL-D는요?
 
- 만약 동일한 파일 디스크립터의 두 호출 사이에서, 첫 번째 fd에서 EOF에 도달하기 전에 다른 파일로 전환될 경우, 우리는 get_next_line이 정의되지 않은 동작을 가진다고 생각합니다.
- 바이너리 파일을 읽을 때 정의되지 않은 동작을 가진다고 생각하셔야 합니다. 그러나 여러분이 원한다면 이러한 동작을 논리적으로 구현하셔도 됩니다.
- 전역 변수는 금지되어 있습니다.
- 중요: 'eof에 도달하였고 \n이 존재하지 않을 때'를 제외하고, 함수가 반환하는 문자열 한 줄에는 \n이 포함되어야 합니다. 

### BONUS
- 하나의 정적변수로 get_next_line 성공하기.
- get_next_line을 사용하여 여러 파일 설명자를 관리할 수 있습니다 
- 예를 들어, 파일 디스크립터 3, 4, 5가 읽기에 액세스 가능하면 각 디스크립터에서 읽기 스레드를 잃지 않고 3에서 한 번, 4에서 한 번, 3에서 다시 한 번, 5에서 한 번 등을 호출할 수 있습니다.
- get_next_line을 사용하여 여러 개의 파일 디스크립터를 관리할 수 있는 것. 
- 예를 들어, 파일 디스크립터 3, 4, 5에 접근 가능한 경우, get_next_line은 각 디스크립터의 리딩 스레드를 잃지 않은 채로 3에서 한 번, 4에서 한 번, 다시 3에서 한 번, 5에서 한 번 호출될 수 있습니다.

### CTRL-D와 CTRL_C의 차이는 무엇인가요?
- CTRL-D는 `파일의 끝(eof)`을 의미합니다.
- CTRL-C는 `중단`을 의미합니다. 즉, 수행 중인 작업을 중지합니다. 기술적으로 많은 프로그램에서 최상위 수준으로 돌아가는 INT 신호를 보냅니다 .

### 리다이렉션이란 무엇인가요?
-  리다이렉션(Redirection)이란 방향을 변경하는 것을 의미합니다. `표준 입력`을 받거나 `표준 출력`을 하는 것 뿐만 아니라, `파일로 표준 입력`을 받고, `파일로 표준 출력을 받는 등의 기능`을 할 수 있습니다.
	- `<` : 파일의 내용을 명령어의 입력으로 사용합니다.
	- `>` : 명령어의 결과(표준 출력)를 파일에 덮어씁니다.
	- `>>` : 명령어의 결과를 파일에 추가합니다.
- 사용법
	- [명령어] 1>[파일] : [명령어] > [파일] 과 같은 의미로, 표준 출력을 [파일]에 덮어씁니다.
	- [명령어] 2>[파일] : [명령어] 실행 시, 에러가 발생한다면, 에러 내용을 [파일]에 덮어씁니다.
	- [명령어] 1>[파일] 2>[파일2] : [명령어] 실행 시, 결과는 [파일]에, 에러는 [파일 2]에 덮어씁니다.
	- [명령어] 1>[파일] 2>[파일] : [명령어] 실행 시, 표준 출려과 에러를 모두 [파일]에 씁니다. 
		- `[명령어] 1> [파일] 2> /dev/null` : 표준 에러(stderr)는 표시되지 않고, 아예 삭제됩니다.
		- `[명령어] > [파일] 2>&1` : 표준 출력(stdout)을 [파일]에 쓰고, 표준 에러(2)를 &1로 보내라는(>) 의미입니다. 이때 &1은, 표준 출력(1)으로 보내는데 백그라운드(&)로 보내라는 의미이다. (백그라운드는 화면에 보이지 말고, 안 보이게 처리해라는 의미)

### 파이프(|)와 리다이렉션의 차이점은 무엇인가요?
- Pipe는 출력을 다른 프로그램 이나 유틸리티 로 넘길 때 사용합니다.
- Redirection은 출력을 파일 이나 스트림으로 넘길 때 사용합니다.

## 파일 디스크립터
- 시스템으로부터 할당받은, 파일(File)을 대표하는 음수가 아닌 정수

### 1. FD table
- File Descriptor Table이며, 머신 단위가 아니라 프로세스 단위로 할당되는 테이블
- 프로세스가 생성되면 기본적으로 0(stdin, 표준 입력), 1(stdout, 표준 출력), 2(stderr, 표준 에러) index가 활성화된다. 해당 공간에는 File table의 주소를 갖게 된다.

### 2. File table
- FD Table이 프로세스 단위로 할당되었다면, File Table은 머신 단위의 할당으로 생성된다. 
- 프로세스에 의해 open된 파일의 읽기/쓰기 동작을 지원하기 위한 테이블. 파일이 열릴 때마다 하나씩 할당된다. 따라서, 만약 하나의 프로세스가 A라는 파일을 3번 open한다면, A의 File Table Entry가 3개 생성된다.
- 이 테이블 Entry 안에는 open_flag, file_offset, ref_cnt, VFS table을 가리키는 포인터가 들어있다.

### 3. VFS i-node(Virtual File System)
- 프로세스들이 사용하고 있는 파일의 i-node를 담고 있는 테이블이다. File Table과는 달리, 만약 하나의 프로세스가 A라는 파일을 3번 open해도 i-node Table Entry는 하나밖에 할당되지 않는다.
- inode를 전체적으로 탐색하게 되면 파일 시스템에 대한 액세스 성능이 굉장히 좋지 않으므로, 이를 극복하기 위해 파일을 열 때마다 사용된 inode를 기록하는 행위가 발생한다. 이 때 기록되는 공간이 VFS inode Cache이며, 내부적으로 기록하며 유지하는 inode는 고유하다. 따라서 파일이 열리게 되면 VFS inode Cache를 먼저 탐색한 후에 전체 탐색에 들어가게 된다.

### 파일 디스크립터가 할당되는 과정
> fd = open("A", O_WRONLY);
1. 커널은 파일시스템에서 파일 A를 찾아 해당 파일의 i-node를 이용해 vfs inode table에 빈 공간에 할당한다. 만약 A의 i-node가 이미 할당되어있는 경우, ref_cnt(reference counter)만 하나 증가시킨다.
2. i-node에 파일에 쓰기권한이 있는지 확인한다.
3. 권한이 있다면 file table의 Entry에 open_flag, file_offset, ref_cnt, VFS i-node table entry 포인터 등의 정보를 할당
4. File descriptor table을 index 0부터 탐색하여, (fd가) 할당되지 않은 index에 file table entry를 가리키는 포인터를 저장한다.
5. 저장한 곳의 index를 반환한다.

### 파일 디스크립터 제한
- 운영체제에서 사용할 수 있는 파일 디스크립터는 제한되어 있다. 이 값은 사용하는 운영체제 혹은 머신에 따라서도 달라질 수 있다.
- 권한이 있는 사용자에 한하여 그 값을 변경하는 것이 가능하다. 
```c
long sysconf(int name); 
// 현재 시스템 상에서 설정된 한 프로세스에서 열 수 있는 최대 파일의 수와 동일한 것을 확인할 수 있다.
```
```bash
$ getconf OPEN_MAX
```
### 파일 디스크립터 변경
- 일반적으로 파일 디스크립터를 한 번에 변경할 수 있는 함수는 존재하지 않는다. 이 때문에 현재 파일에 대한 파일 디스크립터를 변경하고 싶다면 파일 디스크립터를 복제하는 행위로 이와 비슷하게 유도할 수 있다.

### 프로그램과 프로세스
- 일반적으로 `프로그램`이라 함은 컴퓨터에서 실행되는 `명령어 모음 덩어리`라고 볼 수 있다. 이 때의 덩어리는 `Code`와 `Data`로 나뉜다
- 프로그램이 상태(State)를 갖고 있는 것을 프로세스라고 한다.
### 예외처리
- malloc 할당 실패 시.
- BUFFER_SIZE가 0 이하일 때.
 
#include <unistd.h>
### 참고자료
- CTRL-C와 CTRL-D의 차이 https://superuser.com/questions/169051/whats-the-difference-between-c-and-d-for-unix-mac-os-x-terminal#:~:text=Ctrl%20C%20tells%20the%20terminal,as%20a%20desire%20to%20exit.
- 파이프와 리다이렉션의 차이 https://rottk.tistory.com/entry/Redirection%EA%B3%BC-Pipe%EC%9D%98-%EC%B0%A8%EC%9D%B4%EA%B0%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94
- bash 리다이렉션 https://bio-info.tistory.com/87
- FD가 할당되는 과정 https://m.blog.naver.com/songblue61/221391888403
- 파일 등등 https://bigpel66.oopy.io/library/42/inner-circle/3 
